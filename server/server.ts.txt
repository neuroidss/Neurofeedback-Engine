
// server/server.ts
// ==================================================================================
// ğŸ›‘ IMMUTABLE KERNEL - DO NOT EDIT THIS FILE ğŸ›‘
// This server is a generic Process Orchestrator (MCP Factory).
// It has NO business logic. It only exists to spawn and route to other MCPs.
// To add features, create a NEW MCP tool in the client that deploys a script.
// ==================================================================================

import express from 'express';
import cors from 'cors';
import fs from 'fs/promises';
import path from 'path';
import { spawn, ChildProcess } from 'child_process';
import { createServer, type Server } from 'net';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
const PORT = 3001;
const SCRIPTS_DIR = path.join(__dirname, 'scripts');
const ASSETS_DIR = path.join(__dirname, 'assets');
const TOOLS_DB_PATH = path.join(__dirname, 'tools.json');

// State
const managedProcesses: Map<string, { 
    process: ChildProcess; 
    logs: string[]; 
    scriptPath: string; 
    port: number; 
    type: 'node' | 'python';
    startTime: number;
}> = new Map();

// NEW: Track ports currently being set up to prevent race conditions during async port checks
// This set holds ports that have been handed out by findFreePort but might not be listening yet.
const pendingPortReservations: Set<number> = new Set();

const MAX_LOGS = 2000;

app.use(cors());
app.use(express.json({ limit: '50mb' }));
app.use('/scripts', express.static(SCRIPTS_DIR));
app.use('/assets', express.static(ASSETS_DIR));

// --- Utils ---

const addLog = (logArray: string[], log: string) => {
    // Clean up ANSI codes if present, though usually raw text is fine.
    // We prefix with timestamp.
    logArray.push(`[${new Date().toISOString()}] ${log}`);
    if (logArray.length > MAX_LOGS) logArray.shift();
};

const findFreePort = async (startPort: number): Promise<number> => {
    const isPortFree = (port: number): Promise<boolean> => {
        return new Promise((resolve) => {
            const server: Server = createServer();
            server.once('error', () => resolve(false));
            server.once('listening', () => { server.close(() => resolve(true)); });
            server.listen(port, '127.0.0.1');
        });
    };

    // Gather all ports that are technically "busy" (active processes or pending setup)
    const busyPorts = new Set<number>(pendingPortReservations);
    managedProcesses.forEach(p => { if (p.port) busyPorts.add(p.port); });

    let port = startPort;
    while (true) {
        if (busyPorts.has(port)) {
            port++;
            continue;
        }
        
        // Optimistically reserve to block other concurrent calls
        pendingPortReservations.add(port);
        
        const free = await isPortFree(port);
        if (free) {
            // Keep reservation. The caller is responsible for clearing it 
            // (or we clear it on timeout/success). 
            // In this specific architecture, we leave it in pendingPortReservations 
            // for a few seconds to ensure managedProcesses.set happens before we rely solely on that map.
            setTimeout(() => pendingPortReservations.delete(port), 10000);
            return port;
        } else {
            pendingPortReservations.delete(port); // Release if not actually free at OS level
            port++;
        }
    }
};

// --- 1. MCP Management API ---

app.get('/api/tools', async (req, res) => {
    try {
        const data = await fs.readFile(TOOLS_DB_PATH, 'utf-8');
        res.json(JSON.parse(data));
    } catch (e) {
        res.json([]);
    }
});

app.post('/api/files/write', async (req, res) => {
    try {
        const { filePath, content, baseDir } = req.body;
        if (!filePath || typeof content !== 'string') return res.status(400).json({ error: "Missing 'filePath' or 'content'." });
        
        const targetBaseDir = (baseDir === 'assets') ? ASSETS_DIR : SCRIPTS_DIR;
        const safeFileName = path.normalize(filePath).replace(/^(\.\.(\/|\\|$))+/, '');
        const fullPath = path.join(targetBaseDir, safeFileName);
        
        await fs.mkdir(path.dirname(fullPath), { recursive: true });
        await fs.writeFile(fullPath, content);
        
        console.log(`[KERNEL] Wrote file: ${safeFileName}`);
        res.status(201).json({ success: true, message: `File '${safeFileName}' written.` });
    } catch (error) {
        res.status(500).json({ error: (error as Error).message });
    }
});

app.post('/api/execute', async (req, res) => {
    const { name, arguments: args } = req.body;
    
    try {
        switch (name) {
            case 'Start Node Process':
            case 'Start Python Process': {
                const { processId, scriptPath, venv } = args;
                if (managedProcesses.has(processId) && !managedProcesses.get(processId)!.process.killed) {
                    return res.json({ success: true, message: `Process '${processId}' is already running.`, port: managedProcesses.get(processId)!.port });
                }

                const fullScriptPath = path.join(SCRIPTS_DIR, scriptPath);
                const port = await findFreePort(4000);
                const logs: string[] = [];
                const isPython = name.includes('Python');
                
                let command = 'node';
                let shellArgs = ['--loader', 'ts-node/esm', fullScriptPath];
                let options: any = { 
                    cwd: __dirname, 
                    env: { ...process.env, PORT: port.toString(), SHARD_ID: processId } 
                };

                if (isPython) {
                    // Determine Python Executable
                    command = 'python3';
                    if (venv) {
                        // Locate venv relative to server root
                        const venvPython = path.join(__dirname, venv, 'bin', 'python');
                        command = venvPython;
                    }
                    console.log(`[KERNEL] Using Python Interpreter: ${command}`);
                    
                    shellArgs = ['-u', fullScriptPath];
                    options = { 
                        cwd: SCRIPTS_DIR, 
                        env: { ...process.env, PORT: port.toString(), PYTHONUNBUFFERED: '1' } 
                    };
                }
                
                console.log(`[KERNEL] Spawning ${processId} using ${command} on port ${port} ${venv ? `(venv: ${venv})` : ''}`);

                const child = spawn(command, shellArgs, options);

                managedProcesses.set(processId, { process: child, logs, scriptPath, port, type: isPython ? 'python' : 'node', startTime: Date.now() });

                child.stdout?.on('data', d => { const m = d.toString().trim(); if(m) { console.log(`[${processId}] ${m}`); addLog(logs, m); }});
                child.stderr?.on('data', d => { const m = d.toString().trim(); if(m) { console.error(`[${processId} ERR] ${m}`); addLog(logs, `ERR: ${m}`); }});
                child.on('close', c => addLog(logs, `Exited with code ${c}`));

                // Wait for port or timeout
                let attempts = 0;
                while (attempts < 20) {
                    await new Promise(r => setTimeout(r, 500));
                    try {
                        // Simple check if something is listening
                        await fetch(`http://127.0.0.1:${port}/`);
                        return res.json({ success: true, message: `Started ${processId}`, port });
                    } catch (e) { 
                        // If conn refused, keep waiting. If 404/etc, it's up.
                        if (!(e as Error).message.includes('ECONNREFUSED')) {
                             return res.json({ success: true, message: `Started ${processId}`, port });
                        }
                    }
                    attempts++;
                }
                return res.json({ success: true, message: `Started ${processId} (Port ${port} active)`, port });
            }

            case 'Stop Process': {
                const { processId } = args;
                const p = managedProcesses.get(processId);
                if (p) {
                    p.process.kill();
                    managedProcesses.delete(processId);
                    return res.json({ success: true, message: `Stopped ${processId}` });
                }
                return res.status(404).json({ error: "Process not found" });
            }

            case 'List Managed Processes': {
                const list = Array.from(managedProcesses.entries()).map(([id, p]) => ({
                    processId: id,
                    port: p.port,
                    uptime: (Date.now() - p.startTime) / 1000,
                    logs: p.logs, // Return all logs (client filters/displays)
                    type: p.type
                }));
                return res.json({ success: true, processes: list });
            }
            
            default:
                return res.status(400).json({ error: `Unknown generic command: ${name}` });
        }
    } catch (e) {
        res.status(500).json({ error: (e as Error).message });
    }
});

// --- 2. Universal Router (The Gateway) ---
// Forwards /mcp/:processId/some/api -> http://localhost:{port}/some/api
app.use('/mcp/:processId', async (req, res) => {
    const { processId } = req.params;
    const proc = managedProcesses.get(processId);
    
    if (!proc) {
        return res.status(404).json({ error: `MCP '${processId}' not found. Is it running?` });
    }

    const targetUrl = `http://127.0.0.1:${proc.port}${req.url.replace(`/${processId}`, '')}`;
    
    try {
        const options: RequestInit = {
            method: req.method,
            headers: { ...req.headers } as any,
            body: ['GET', 'HEAD'].includes(req.method) ? undefined : JSON.stringify(req.body),
        };
        // Remove host header to avoid confusion
        delete (options.headers as any)['host'];
        delete (options.headers as any)['content-length'];
        if (!['GET', 'HEAD'].includes(req.method)) {
             (options.headers as any)['Content-Type'] = 'application/json';
        }

        const response = await fetch(targetUrl, options);
        
        // Forward headers
        response.headers.forEach((val, key) => res.setHeader(key, val));
        res.status(response.status);
        
        const buffer = await response.arrayBuffer();
        res.send(Buffer.from(buffer));

    } catch (e) {
        res.status(502).json({ error: `Bad Gateway to MCP '${processId}': ${(e as Error).message}` });
    }
});

app.listen(PORT, async () => {
    console.log(`
    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â•‘  NEUROFEEDBACK UNIVERSAL KERNEL (PORT ${PORT})      â•‘
    â•‘  Status: ONLINE                                    â•‘
    â•‘  Mode:   Process Orchestrator                      â•‘
    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    `);
    await fs.mkdir(SCRIPTS_DIR, { recursive: true });
    await fs.mkdir(ASSETS_DIR, { recursive: true });
});
